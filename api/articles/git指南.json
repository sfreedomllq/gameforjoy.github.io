{"title":"git指南","slug":"git指南","date":"2018-12-04T08:05:33.000Z","updated":"2018-12-04T09:20:00.328Z","comments":true,"path":"api/articles/git指南.json","photos":[],"link":"","excerpt":"git中级指南常用命令git status  //查看当前状态git log  //查看当前分支commit logsgit add . //添加当前文件夹下所有变动git reset HEAD //重置 HEAD 的状态git commit -m “commit message” //commit操作git checkout branch_name //检出分支git checkout 23abef // 检出指定commitgit checkout . //还原尚未分级的改动git checkout -b branch_name //新建分支<br>","covers":["/2018/12/04/git指南/1.jpg","/2018/12/04/git指南/2.jpg","/2018/12/04/git指南/3.jpg","/2018/12/04/git指南/4.jpg","/2018/12/04/git指南/5.jpg","/2018/12/04/git指南/6.jpg","/2018/12/04/git指南/7.jpg","/2018/12/04/git指南/8.jpg","/2018/12/04/git指南/9.jpg"],"content":"<h1 id=\"git中级指南\"><a href=\"#git中级指南\" class=\"headerlink\" title=\"git中级指南\"></a>git中级指南</h1><h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p>git status  //查看当前状态</p>\n<p>git log  //查看当前分支commit logs</p>\n<p>git add . //添加当前文件夹下所有变动</p>\n<p>git reset HEAD //重置 HEAD 的状态</p>\n<p>git commit -m “commit message” //commit操作</p>\n<p>git checkout branch_name //检出分支</p>\n<p>git checkout 23abef // 检出指定commit</p>\n<p>git checkout . //还原尚未分级的改动</p>\n<p>git checkout -b branch_name //新建分支<br><a id=\"more\"></a><br>git branch -m new_branch_name //分支重命名</p>\n<p>git branch -d branch_name //删除分支</p>\n<p>git merge another_branch_name //将另一个分支合并到当前分支</p>\n<p>git remote add origin <a href=\"mailto:git@remote.repo.url\" target=\"_blank\" rel=\"noopener\">git@remote.repo.url</a> //添加远程上级源</p>\n<p>git fetch //获取远程源的最新代码</p>\n<p>git pull //获取原成员的最新代码并融合（fetch+merge）</p>\n<p>git push //将本地源推送至远程源</p>\n<p>如果你对以上的命令不是很熟悉，请参考一些网络资料：</p>\n<ol>\n<li>Pro Git ：<a href=\"https://git-scm.com/book\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/book</a></li>\n<li>Git Documentation ：<a href=\"https://git-scm.com/doc\" target=\"_blank\" rel=\"noopener\">https://git-scm.com/doc</a></li>\n<li>Tutorials from Atlassian ： <a href=\"https://www.atlassian.com/git/tutorials/\" target=\"_blank\" rel=\"noopener\">https://www.atlassian.com/git/tutorials/</a></li>\n</ol>\n<h3 id=\"历史版本管理\"><a href=\"#历史版本管理\" class=\"headerlink\" title=\"历史版本管理\"></a>历史版本管理</h3><p>git reset –soft HEAD~3 // 回滚commit，保留改变</p>\n<p>git reset –hard HEAD~3 // 回滚commit，不保留变更</p>\n<p>git reset –mixed HEAD~3 // 回滚commit，保留变更，清空暂存</p>\n<p>git reflog // 意外回滚了一次commit？ 别着急，有补救办法</p>\n<p>git checkout 42efba //根据hash点检出</p>\n<p>git checkout -B master //替换源点分支</p>\n<p>git cherry-pick 892bfe //从其它分支中挑出一个commit，但不合并</p>\n<p>git cherry-pick 892bfe..42fdab //一次挑出多个commit</p>\n<p>git cherry-pick –continue //用于操作中断（如处理冲突）后的继续</p>\n<p>git cherry-pick –abort //放弃这次pick</p>\n<p>git rebase HEAD^10 //</p>\n<p>git rebase master //将当前分支和master进行rebase。rebase与merge相比，提交历史更加干净，线性，整洁。</p>\n<p>git rebase -i HEAD~3 //交互式的rebase，可以帮助我们：挑选或放弃commit；更改commit命令；更改commit信息；修改编辑内容；将两个commit合并成一个</p>\n<p>强烈推荐在本地开发分支上同步远程源时用rebase命令代替merge命令，这样会使你的commit历史看上去更加简洁</p>\n<p>那么问题来了： rebase和merge的区别是什么？<br><img src=\"/2018/12/04/git指南/1.jpg\" alt=\"alt\"></p>\n<p><img src=\"/2018/12/04/git指南/2.jpg\" alt=\"alt\"></p>\n<p>git merge :不改变master和develop分支上的任何commit<br>           在develop分支上新生成一个merge的commit<br>           一旦合并回来，develop分支上的merge提交将会出现在master分支中</p>\n<p>git rebase ： 将会重写来自develop分支上的commit<br>              将会清除空的commit并保持log的整洁</p>\n<p><img src=\"/2018/12/04/git指南/3.jpg\" alt=\"alt\"></p>\n<p><img src=\"/2018/12/04/git指南/4.jpg\" alt=\"alt\"></p>\n<p><strong> rebase的黄金定律：永远不要在公有分支上使用rebase。 </strong></p>\n<p>其它注意事项：</p>\n<ol>\n<li>一旦使用了rebase，在向远程推送的时候也许需要使用 git push -f。使用前请确认是在你自己的分支上，而不要再master分支上执行此操作。</li>\n<li>默认状态下 git pull 等价于 git fetch + git merge。你可以通过此命令进行修改： git pull –rebase</li>\n</ol>\n<p>一些你可能不知道的 git 命令：<br>git grep<br>多线程，比单独的 grep 命令快很多<br>默认情况下输出更少</p>\n<p>git clean<br>清除没有提交的文件<br>不可回滚</p>\n<p>gitk， git gui<br>git内置的GUI客户端</p>\n<p>让 git log 以树形图展示：<br>git log –graph –oneline –decorate<br><img src=\"/2018/12/04/git指南/5.jpg\" alt=\"alt\"></p>\n<p><strong> commit 究竟是什么！？ 参见： <a href=\"http://whatthecommit.com/\" target=\"_blank\" rel=\"noopener\">http://whatthecommit.com/</a> </strong></p>\n<p>要描述 git 的对象模型就跟要回答下面这个问题一样，因为我们的文件系统就跟一个数据结构树一样。<br>问题：怎样在内存树中创建一个不可变量，而且可以查找它的修改历史并随意恢复到以前的状态?<br><img src=\"/2018/12/04/git指南/6.jpg\" alt=\"alt\"></p>\n<p>简单来说：<br>每改变一次，我们就将改变后的样子记录下来并存放在某处；<br>根据顺序，用一系列的指针指向每一个副本；<br>一旦我们想要知道过去的某个时间点这玩意是什么样，我们就可以在这一堆指针中找到符合我们要求的，然后进行回滚。<br>但这消耗了太多的内存，并且执行起来很慢。<br><img src=\"/2018/12/04/git指南/7.jpg\" alt=\"alt\"></p>\n<p><img src=\"/2018/12/04/git指南/8.jpg\" alt=\"alt\"></p>\n<p><strong> 结论： </strong><br>我们可以通过以下处理来优化之前的方案：<br>1.每次发生改变，我们只记录改变的东西，除非是从根到子节点全部都做了改变。这样会节约很多内存和时间；<br>2.我们用一些列的追踪点来保存历史中每个时间点的顺序；每个点都有一个指向源副本的指针，追踪点也有指向之前节点的指针；<br>3.当我们需要某一历史版本时，只需要找到追踪点，获取此点所指向的根，从而遍历树得到我们想要的时间点的快照。</p>\n<p><strong> 至此： </strong><br>你已经了解了 Git 的对象模型！<br>Git 为每一个文件夹和文件设置了对象并存放在  .git/objects 中；<br>Git 模型对象的每个追踪点与对应的commit也都存放在 .git/objects中；<br>每一步你所执行的操作，Git都将小心翼翼的维护着这些对象文件和其之间的联系，这保证了这些对象与你的源文件的一致性。</p>\n<p>看一下 Git 内部的文件（部分省略）：<br><img src=\"/2018/12/04/git指南/9.jpg\" alt=\"alt\"></p>\n<p>objects 和其子文件夹中包含了所有的 objects：<br>    每个object 都又它们经过 SHA1 算法加密的哈希值作为索引；<br>    前两个字符被提取出来命名一个分类级的文件夹；<br>    info 和 pack 方法待会再解释。。<br>refs 和其子文件夹包含了所有的指针，分支，标签等等；<br>HEAD 指向的是当前工作文件夹下的commit hash。</p>\n<p>默认情况下 Git 的对象都是由 zlib 压缩的，我们可以通过以下 python 代码将其解压来阅读：</p>\n<pre><code># -*- codingL utf-8 -*- #\n\nimport sys\nimport zlib\n\ndef main(fname):\n    with open(fname) as f:\n        print zlib.decompress(f.read())\n\nif __name__ == &quot;__main__&quot;:\n    main(sys.argv[1])\n</code></pre><p>或者使用 Git 自身所提供的方法 ：<br>git cat-file -p 5b67fd90081</p>\n","categories":[{"name":"文档","slug":"文档","count":2,"path":"api/categories/文档.json"}],"tags":[{"name":"git","slug":"git","count":1,"path":"api/tags/git.json"}]}